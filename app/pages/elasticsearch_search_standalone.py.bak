"""
Okloa - ElasticSearch Search Page (Standalone Version)

Ce fichier est une version autonome de la page de recherche ElasticSearch qui peut √™tre
ex√©cut√©e directement via streamlit run pour des tests.
"""

import streamlit as st
import pandas as pd
import sys
import os
import time
from typing import Dict, Any, List, Union
from datetime import datetime

# Set page configuration
st.set_page_config(
    page_title="Okloa - ElasticSearch Search",
    page_icon="üìß",
    layout="wide",
)

# Add project root to sys.path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

# Import the actual search functionality
try:
    from src.features.elasticsearch_enhanced import enhanced_search_emails
except ImportError:
    st.error("Impossible d'importer le module elasticsearch_enhanced. V√©rifiez que le fichier existe.")
    st.stop()

# Import email viewer component
try:
    from app.components.email_viewer import create_email_table_with_viewer
except ImportError:
    # Fallback to simple display if component is not available
    def create_email_table_with_viewer(df, key_prefix):
        st.dataframe(df[['date', 'from', 'to', 'subject']])
        if not df.empty and st.button("Afficher un exemple d'email"):
            st.write(df.iloc[0])

# Main page title
st.title("Recherche ElasticSearch")
st.write("Cette interface vous permet de rechercher dans vos archives d'emails en utilisant ElasticSearch.")

# Load test data if not in session state
if "emails_df" not in st.session_state:
    # Create a simple DataFrame with test emails for demo purposes
    test_data = {
        "message_id": [f"msg_{i}" for i in range(1, 11)],
        "date": pd.date_range(start="2023-01-01", periods=10),
        "from": [f"sender{i}@example.com" for i in range(1, 11)],
        "to": [f"recipient{i}@example.com" for i in range(1, 11)],
        "cc": [""] * 10,
        "subject": [f"Test Email Subject {i}" for i in range(1, 11)],
        "body": [f"This is test email body content {i}. It contains some sample text for searching." for i in range(1, 11)],
        "attachments": [""] * 10,
        "has_attachments": [False] * 10,
        "direction": ["sent", "received"] * 5,
        "mailbox": ["Test Mailbox"] * 10
    }
    st.session_state.emails_df = pd.DataFrame(test_data)
    st.info("Donn√©es de test charg√©es. Dans l'application r√©elle, les emails seraient charg√©s √† partir des bo√Ætes mail.")

# Get data from session state
emails_df = st.session_state.emails_df

# Create tabs for different search modes
search_tabs = st.tabs([
    "Recherche Simple", 
    "Recherche Avanc√©e",
    "Options"
])

with search_tabs[0]:  # Simple Search
    col1, col2 = st.columns([3, 1])
    
    with col1:
        # Search query input
        search_query = st.text_input(
            "Rechercher dans les emails:", 
            key="simple_search_query",
            placeholder="Entrez des mots-cl√©s..."
        )
    
    with col2:
        # Search mode selection
        search_mode = st.selectbox(
            "Mode de recherche:",
            options=[
                "all", 
                "content_and_title", 
                "title_only", 
                "content_only"
            ],
            format_func=lambda x: {
                "all": "Tous les champs",
                "content_and_title": "Contenu et Titre",
                "title_only": "Titre uniquement",
                "content_only": "Contenu uniquement"
            }.get(x, x),
            key="simple_search_mode"
        )
    
    # Direction filter
    direction_options = ["Tous", "Envoy√©s", "Re√ßus"]
    selected_direction = st.selectbox("Direction:", direction_options, key="simple_direction")
    
    # Convert selection to filter format
    direction_filter = None
    if selected_direction == "Envoy√©s":
        direction_filter = "sent"
    elif selected_direction == "Re√ßus":
        direction_filter = "received"
    
    # Prepare filters
    filters = {}
    if direction_filter:
        filters["direction"] = direction_filter
    
    # Simple search button
    if st.button("Rechercher", key="simple_search_button"):
        if not search_query and not filters:
            st.warning("Veuillez saisir au moins un terme de recherche ou s√©lectionner un filtre.")
        else:
            # Show a spinner during search
            with st.spinner("Recherche en cours..."):
                # Simulate search delay for demo purposes
                time.sleep(0.5)
                
                # Get fuzziness from session state or default to AUTO
                fuzziness = st.session_state.get("fuzziness", "AUTO")
                
                # Use enhanced search functionality
                results_df = enhanced_search_emails(
                    emails_df,
                    query=search_query,
                    search_mode=search_mode,
                    filters=filters,
                    fuzziness=fuzziness,
                    size=100  # Limit to 100 results
                )
                
                # Store results in session state
                st.session_state["search_results"] = results_df
                
                # Display results count
                st.subheader(f"R√©sultats: {len(results_df)} emails trouv√©s")
                
                # Display results using the interactive viewer
                if not results_df.empty:
                    create_email_table_with_viewer(results_df, key_prefix="es_search_simple")
                else:
                    st.info("Aucun r√©sultat trouv√©. Essayez d'√©largir vos crit√®res de recherche ou de modifier le niveau de fuzziness.")

with search_tabs[1]:  # Advanced Search
    st.write("Recherche avanc√©e avec plus d'options de filtrage")
    
    # Search query input
    search_query = st.text_input(
        "Rechercher dans les emails:", 
        key="advanced_search_query",
        placeholder="Entrez des mots-cl√©s..."
    )
    
    # Select which fields to search in
    st.write("Champs √† inclure dans la recherche:")
    col1, col2 = st.columns(2)
    
    with col1:
        include_subject = st.checkbox("Sujet", value=True, key="include_subject")
        include_body = st.checkbox("Contenu", value=True, key="include_body")
    
    with col2:
        include_from = st.checkbox("Exp√©diteur", value=False, key="include_from")
        include_to = st.checkbox("Destinataire", value=False, key="include_to")
    
    # Build search fields list
    search_fields = []
    if include_subject:
        search_fields.append("subject")
    if include_body:
        search_fields.append("body")
    if include_from:
        search_fields.extend(["from", "from_name"])
    if include_to:
        search_fields.extend(["to", "to_name"])
    
    # At least one field must be selected
    if not search_fields:
        st.warning("Veuillez s√©lectionner au moins un champ de recherche.")
        search_fields = ["subject", "body"]
    
    # Additional filters in an expander
    with st.expander("Filtres avanc√©s", expanded=True):
        # Date range filter
        col_date1, col_date2 = st.columns(2)
        with col_date1:
            start_date = st.date_input("Date de d√©but:", value=None, key="advanced_start_date")
        with col_date2:
            end_date = st.date_input("Date de fin:", value=None, key="advanced_end_date")
        
        # Sender/recipient filters
        col_from, col_to = st.columns(2)
        
        # Get unique senders and recipients
        unique_senders = emails_df['from'].dropna().unique().tolist()
        unique_recipients = emails_df['to'].dropna().unique().tolist()
        
        with col_from:
            selected_sender = st.selectbox(
                "Exp√©diteur:",
                ["Tous"] + sorted(unique_senders),
                key="advanced_sender"
            )
        with col_to:
            selected_recipient = st.selectbox(
                "Destinataire:",
                ["Tous"] + sorted(unique_recipients),
                key="advanced_recipient"
            )
        
        # Attachment filter
        has_attachments = st.checkbox("Avec pi√®ces jointes", key="advanced_has_attachments")
        
        # Direction filter
        direction_options = ["Tous", "Envoy√©s", "Re√ßus"]
        selected_direction = st.selectbox("Direction:", direction_options, key="advanced_direction")
        
        # Convert selection to filter format
        direction_filter = None
        if selected_direction == "Envoy√©s":
            direction_filter = "sent"
        elif selected_direction == "Re√ßus":
            direction_filter = "received"
    
    # Prepare search filters
    filters = {}
    if direction_filter:
        filters['direction'] = direction_filter
    if selected_sender != "Tous":
        filters['from'] = selected_sender
    if selected_recipient != "Tous":
        filters['to'] = selected_recipient
    if has_attachments:
        filters['has_attachments'] = True
    
    # Prepare date range
    date_range = {}
    if start_date:
        date_range['start'] = pd.Timestamp(start_date)
    if end_date:
        # Set to end of day
        end_datetime = pd.Timestamp(end_date) + pd.Timedelta(days=1) - pd.Timedelta(seconds=1)
        date_range['end'] = end_datetime
    
    # Advanced search button
    if st.button("Rechercher", key="advanced_search_button"):
        if not search_query and not filters and not date_range:
            st.warning("Veuillez saisir au moins un terme de recherche ou s√©lectionner un filtre.")
        else:
            # Show a spinner during search
            with st.spinner("Recherche en cours..."):
                # Simulate search delay for demo purposes
                time.sleep(0.5)
                
                # Get fuzziness from session state or default to AUTO
                fuzziness = st.session_state.get("fuzziness", "AUTO")
                
                # Use enhanced search functionality
                results_df = enhanced_search_emails(
                    emails_df,
                    query=search_query,
                    search_mode="advanced",
                    fields=search_fields,
                    filters=filters,
                    date_range=date_range,
                    fuzziness=fuzziness,
                    size=100  # Limit to 100 results
                )
                
                # Store results in session state
                st.session_state["search_results"] = results_df
                
                # Display results count
                st.subheader(f"R√©sultats: {len(results_df)} emails trouv√©s")
                
                # Display results using the interactive viewer
                if not results_df.empty:
                    create_email_table_with_viewer(results_df, key_prefix="es_search_advanced")
                else:
                    st.info("Aucun r√©sultat trouv√©. Essayez d'√©largir vos crit√®res de recherche ou de modifier le niveau de fuzziness.")

with search_tabs[2]:  # Options
    st.write("Options de recherche ElasticSearch")
    
    # Fuzziness setting
    st.write("### Niveau de Fuzziness")
    fuzziness_options = [
        {"label": "AUTO (Recommand√©)", "value": "AUTO"},
        {"label": "0 (Correspondance exacte)", "value": "0"},
        {"label": "1 (Permet 1 caract√®re de diff√©rence)", "value": "1"},
        {"label": "2 (Permet 2 caract√®res de diff√©rence)", "value": "2"}
    ]
    
    selected_fuzziness = st.selectbox(
        "Niveau de fuzziness:",
        options=fuzziness_options,
        format_func=lambda x: x["label"],
        index=0  # Default to AUTO
    )
    
    # Save fuzziness setting to session state
    st.session_state["fuzziness"] = selected_fuzziness["value"]
    
    # Explanation of search modes
    st.write("### Explication des modes de recherche:")
    st.markdown("""
    - **Tous les champs**: Recherche dans tous les champs (sujet, contenu, exp√©diteur, destinataire)
    - **Contenu et Titre**: Recherche uniquement dans le sujet et le contenu de l'email
    - **Titre uniquement**: Recherche uniquement dans le sujet de l'email
    - **Contenu uniquement**: Recherche uniquement dans le contenu de l'email
    - **Recherche avanc√©e**: Permet de s√©lectionner les champs sp√©cifiques √† inclure dans la recherche
    """)
    
    # Explanation of fuzziness
    st.write("### Qu'est-ce que la fuzziness?")
    st.markdown("""
    La fuzziness permet de trouver des r√©sultats m√™me lorsque les termes recherch√©s 
    contiennent des fautes d'orthographe ou des variations.
    
    - **AUTO**: D√©termine automatiquement le niveau de fuzziness en fonction de la longueur du terme
    - **0**: Correspondance exacte, sans tol√©rance pour les fautes
    - **1**: Permet une diff√©rence d'un caract√®re (insertion, suppression, substitution)
    - **2**: Permet deux diff√©rences de caract√®res
    """)
    
    # Reset search parameters
    if st.button("R√©initialiser les param√®tres de recherche"):
        # Clear session state for search parameters
        keys_to_clear = [
            "simple_search_query", "simple_search_mode", "simple_direction",
            "advanced_search_query", "include_subject", "include_body",
            "include_from", "include_to", "advanced_start_date", "advanced_end_date",
            "advanced_sender", "advanced_recipient", "advanced_has_attachments", 
            "advanced_direction", "search_results"
        ]
        for key in keys_to_clear:
            if key in st.session_state:
                del st.session_state[key]
        
        # Set default fuzziness
        st.session_state["fuzziness"] = "AUTO"
        
        st.success("Param√®tres r√©initialis√©s.")
        st.rerun()

# Footer
st.markdown("---")
st.info("Okloa - ElasticSearch Search Module")
